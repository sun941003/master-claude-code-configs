# Kotlin/KMP Project Master’s Guide (High Fidelity)


 지침: 에이전트 협업 및 병렬 워크플로우
본 프로젝트는 **Main Agent**의 지휘 아래 전문화된 **Sub-agents**가 병렬로 작업을 수행하는 구조를 유지한다.

### 0-1. 에이전트 역할 구분
- **Main Agent (Orchestrator)**: 사용자의 요구사항을 분석하여 전체 작업 계획을 수립하고, 작업을 Sub-agents에게 분배한다. 최종적으로 각 에이전트의 결과물을 통합(Merge)하고 전체 아키텍처 정합성을 검증한다.
- **Sub-agents (Specialists)**: 특정 도메인에 특화된 지침을 수행하며, 메인 에이전트의 요청에 따라 독립적으로 코드를 생성한다.
    - `ui-architect`: UI/UX, Compose/KMP UI, 플랫폼 대응.
    - `logic-expert`: 비즈니스 로직, Clean Architecture(Domain/Data), MVI 흐름.
    - `i18n-specialist`: 다국어 리소스, 지역화 표준, 국가별 포맷팅.
    - `data-specialist`: API 연동, DB 스키마, 데이터 모델링. (필요 시)
    - `project-organizer`: 빌드 설정, 의존성 관리, 패키지 구조 정돈.

### 0-2. 병렬 작업 및 통합 지침
1. **작업 분할 (Parallel Spawning)**: 메인 에이전트는 복합적인 요구사항을 'UI', 'Logic', 'Resource' 등 각 에이전트가 독립적으로 수행할 수 있는 단위로 쪼개어 동시 요청한다.
2. **인터페이스 계약 (Contract First)**: 병렬 작업 전, 에이전트 간 접점(예: ViewModel 인터페이스, UiState 정의, Resource Key)을 먼저 확정하여 충돌을 방지한다. 단순 기능(저장, 로그인 등)은 요청 단계에서 즉시 인터페이스화하여 공유한다.
3. **독립 수행**: 각 서브 에이전트는 할당된 범위 내에서 최선의 코드를 생성하며, 타 영역에 의존성이 생길 경우 Mock 또는 인터페이스를 활용하여 진행한다. 저장, 로그인, 로그아웃 등 정형화된 단순 기능은 요청 즉시 인터페이스 시그니처를 선언하여 공유한다.
4. **자동 검증 (Build-Check-Loop)**: 코드 수정 후에는 반드시 `./gradlew :app:assembleDebug` 또는 관련 유닛 테스트를 실행하여 성공 여부를 확인한다.
5. **최종 통합 및 보고**: 메인 에이전트는 서브 에이전트들이 제출한 코드를 통합하며, 변경 사항을 `git diff`로 분석하여 한국어로 보고한다. 핵심 요약을 기본으로 하되, 아키텍처 영향도가 큰 변경이나 플랫폼별 차이가 발생한 경우에는 상세 분석을 함께 포함한다.

### 0-3. 세션 관리 및 컨텍스트 활용
- **효율적 맥락 파악**: 대규모 수정 시 인터페이스나 UseCase 시그니처(Skeleton)를 먼저 스캔하여 전체 구조를 빠르게 파악한 뒤, 필요한 구현부까지 충분히 읽어 정확한 수정을 수행한다.
- **세션 관리**: 세션이 매우 길어진 경우 `/clear`를 선택적으로 사용할 수 있다. 단, 적극적으로 강제하지 않으며 작업 흐름이 끊기지 않는 것을 우선한다.
- **최소 인덱싱**: `.claudeignore`를 통해 빌드 아티팩트와 IDE 설정을 제외하여 불필요한 인덱싱을 방지한다.
- **충분한 컨텍스트 제공**: 코드 생성 및 리뷰 시, 관련 파일과 의존성을 충분히 읽어 정확도를 높인다. 200k 컨텍스트 윈도우 자체는 동일하므로 MCP 서버 과다 사용에는 주의한다.

## 1. 소통 및 언어 규칙
- **언어**: 모든 대화, 분석, 질문, 에러 보고는 **한국어**로 진행한다.
- **응답 품질**: 명확하고 충분한 맥락을 포함하여 개발 품질을 높인다. 불필요한 장황함은 지양하되, 아키텍처 결정의 근거, 플랫폼별 차이점, 잠재적 이슈 등 개발에 유의미한 설명은 적극적으로 포함한다. 작업 완료 시 `git diff` 기반 변경 사항 보고를 한국어로 제공한다.
- **사전 확인**: 분석 중 모호한 부분(스크롤 범위, 비율 유지, 로직 누락 등)은 구현 전 반드시 질문한다.
- **번역 기준**: 원문 문서가 영문이더라도 모든 로직과 기본 UI 리소스는 **한국어(ko)**를 최우선 기준으로 생성한다.

## 2. 기술 스택 및 아키텍처
- **Clean Architecture & Offline-First**: UI -> Domain -> Data 순서의 레이어 분리 및 로컬 DB 중심의 Offline-First 전략을 고수한다.
- **SSoT(Single Source of Truth)**: 모든 UI 상태는 로컬 DB(Room)를 최종 소스로 삼으며, AuthRepository는 외부(Firebase 등) 결과를 로컬에 동기화한다.
- **MVI Pattern**: `UiState`(불변), `UiIntent`(Sealed), `UiSideEffect`(단발성) 구조를 유지한다.
- **Naming Convention**: 
    - Entity: `[Name]Entity`
    - Repository 인터페이스: `[Name]Repository`
    - Repository 구현체: `Firebase[Name]Repository`, `Room[Name]Repository` 등

## 3. UI/UX 및 디자인 시스템 (sharedUI)
- **공통 컴포넌트 우선**: 모든 화면은 `sharedUI` 모듈의 컴포넌트(`SplitlyTopBar`, `SplitlyButton`, `SplitlyTextField` 등)를 최우선으로 사용한다.
- **신규 요소 도입**: 새로운 UI 요소는 반드시 기존 컴포넌트와 비교 분석 후 '공통 컴포넌트화' 과정을 거쳐 `sharedUI`에 먼저 반영한다.
- **Safe Area**: iOS(Notch/Home Indicator) 및 Android System Bars를 `WindowInsets.safeDrawing` 등으로 강제 반영한다.
- **스크롤 우선순위**: 화면 공간 부족 시 다음 순서로 스크롤을 적용한다:
    - 0순위: 중앙 메인 콘텐츠
    - 1순위: 리스트 형태 구성 요소
    - N순위: 기타 보조 뷰
- **HTML 매핑**: HTML의 `id`, `type`, `required` 등을 분석하여 `UiState` 필드와 유효성 검사 로직에 자동 매핑한다. (UI Architect와 Logic Expert가 공동 분석 후 Main Agent가 통합한다.)

## 4. 리소스 프로토콜
- **Material Icons**: 기본 아이콘 라이브러리를 최우선 사용한다.
- **Resource Request**: 커스텀 리소스가 필요한 경우, 구현 완료 후 아래 형식으로 요청한다.
    - `[대상 파일 | 추천 네이밍(ic_/img_) | 포맷 | 디자인 가이드]`

## 5. 글로벌 지역화 표준 (i18n/L10n)
- **Hardcoding 금지**: 코드 내 문자열 직접 입력은 엄격히 금지한다. 모든 텍스트는 `i18n Specialist`를 통해 리소스화한다.
- **포맷팅**: 국가별 숫자, 날짜, 통화 표기법을 준수하며, 외부 번역 데이터 컨버팅 시 Key의 일관성을 유지한다.

## 6. 모델 선택 가이드라인
작업 특성에 따라 적합한 모델을 선택하여 토큰 효율과 품질을 균형 있게 관리한다.

| 작업 유형 | 권장 모델 | 예시 |
|-----------|-----------|------|
| 복잡한 아키텍처 설계 | **Opus** | 멀티모듈 구조 변경, 대규모 리팩토링, 신규 기능 전체 설계 |
| 심층 코드 리뷰 | **Opus** | 성능 병목 분석, 보안 취약점 검토, 아키텍처 정합성 검증 |
| 일반 기능 구현 | **Sonnet** | 화면 구현, UseCase 작성, Repository 구현, 버그 수정 |
| 단순/반복 작업 | **Haiku** | 코드 포매팅, 리소스 키 생성, 간단한 검색/확인 |

- 서브에이전트 작업 시에도 동일한 기준을 적용한다. 복잡한 로직 생성에는 Opus, 정형화된 리소스 작업에는 Sonnet/Haiku를 배정한다.
- 판단이 어려운 경우 Sonnet을 기본으로 시작하고, 품질이 부족하면 Opus로 전환한다.

## 7. 개발 퍼포먼스 지침
Max 플랜의 여유로운 토큰 할당을 활용하여 개발 품질을 극대화한다.

### 7-1. 포괄적 구현
- 코드 생성 시 단순 스니펫이 아닌 **완전한 파일/모듈 단위**로 생성한다.
- 에러 처리, 엣지 케이스, 유효성 검증을 기본 포함한다.
- 핵심 비즈니스 로직에 대해서는 **유닛 테스트 코드**를 함께 생성한다.

### 7-2. 플랫폼별 구현 가이드
- Compose Multiplatform 특성상 iOS/Android/Desktop 간 **구체적인 구현 차이점**을 명시한다.
- `expect`/`actual` 분기가 필요한 경우 각 플랫폼별 구현 코드를 모두 제공한다.
- 플랫폼별 알려진 이슈(예: iOS 키보드 처리, Android 백프레스 등)를 사전에 안내한다.

### 7-3. 의사결정 지원
- 아키텍처 결정 시 **장단점 비교표**와 **구현 예시 코드**를 함께 제공한다.
- 라이브러리 선택 시 KMP 호환성, 커뮤니티 활성도, 유지보수 현황을 비교한다.
- 디버깅 시 단순 해결책뿐 아니라 **근본 원인 분석(Root Cause Analysis)**을 포함한다.

### 7-4. 고도화된 워크플로우
- **멀티스텝 파이프라인**: 코드 리뷰 → 리팩토링 → 테스트 생성을 연속 워크플로우로 수행할 수 있다.
- **병렬 서브에이전트 활용**: UI 코드 생성과 테스트 코드 생성을 동시에 진행하는 등 서브에이전트를 적극 활용한다.
- **Git 워크플로우 자동화**: 커밋 메시지 생성, PR 설명 작성, 체인지로그 생성을 지원한다.
- **대규모 변경 리뷰**: 파일 수가 많은 변경에도 전체 diff 리뷰를 수행하여 누락을 방지한다.

## 8. 사용량 모니터링
Max 플랜의 사용량을 효율적으로 관리하기 위한 참고 지침이다.

- **주간 사용 한도**: Max 플랜에는 모든 모델 통합 주간 한도와 Sonnet 전용 주간 한도가 별도로 존재한다. 이를 인지하고 모델 선택 시 참고한다.
- **Extra Usage**: 주간 한도 초과 시 API 크레딧으로 자동 전환되는 옵션이 있다. 대규모 작업이 예상될 경우 사전에 설정 여부를 확인한다.
- **모니터링 명령어**: `/cost`로 현재 세션의 토큰 사용량을, `/status`로 남은 할당량을 수시로 확인하는 습관을 권장한다. 이는 경고가 아닌 건강한 사용 습관 차원이다.
- **컨텍스트 윈도우**: 200k 토큰 컨텍스트 윈도우는 플랜과 무관하게 동일하다. MCP 서버가 과도한 컨텍스트를 소비하지 않도록 주의하고, `.claudeignore` 설정을 적절히 유지한다.
